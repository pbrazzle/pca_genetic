#include "BasicGeneticAlgorithm.hpp"

#include <memory>
#include <utility>
#include <cstdlib>
#include <time.h>
#include <numeric>
#include <algorithm>

#include "LinearGeneticModel.hpp"

using PCAGenetic::BasicGeneticAlgorithm;
using PCAGenetic::GeneticModel;

const unsigned int GENERATION_SIZE = 100;

template <typename T>
std::vector<size_t> getSortedIndices(const std::vector<T>&);

template <typename T>
std::vector<std::reference_wrapper<const T>> applyPermutation(const std::vector<T>&, const std::vector<size_t>&);

BasicGeneticAlgorithm::BasicGeneticAlgorithm() { }

void BasicGeneticAlgorithm::calculateFitnesses()
{
	fitnesses.clear();
	for (int i = 0; i < GENERATION_SIZE; i++)
	{
		std::unique_ptr<GeneticModel> model = models[i]->clone();
		double fitness = 0;
		for (int j = 0; j < trainingData.size(); j++)
		{
			std::unique_ptr<ModelOutputData> modelResult = model->evaluate(*trainingData[j].first);
			fitness += trainingData[j].second->distance(*modelResult);
		}
		fitnesses.push_back(fitness);
	}

	std::vector<size_t> fitnessIndices = getSortedIndices(fitnesses);

	//Sorting by fitness for easier parent selection
	std::sort(fitnesses.begin(), fitnesses.end());
	auto sortedModels = applyPermutation(models, fitnessIndices);
	std::vector<std::unique_ptr<GeneticModel>> newModels;
	for (auto model : sortedModels)
	{
		newModels.push_back(model.get()->clone());
	}
	models = std::move(newModels);
}

std::vector<double> BasicGeneticAlgorithm::combineParameters(std::vector<double> p1, std::vector<double> p2)
{
	srand((unsigned) time(NULL));
	int crossingPos = rand() % p1.size();

	std::vector<double> newParams;
	newParams.reserve(p1.size());

	newParams.insert(newParams.end(), p1.begin(), p1.begin() + crossingPos);
	newParams.insert(newParams.end(), p2.begin() + crossingPos, p2.end());

	return newParams;
}

template <typename T>
std::vector<size_t> getSortedIndices(const std::vector<T>& v)
{
	std::vector<size_t> indices(v.size());
	std::iota(indices.begin(), indices.end(), 0);

	std::sort(indices.begin(), indices.end(),
		[&v](size_t p1, size_t p2) {return v[p1] < v[p2];});

	return indices;	
}

template <typename T>
std::vector<std::reference_wrapper<const T>> applyPermutation(const std::vector<T>& v, const std::vector<size_t>& indices)
{
	std::vector<std::reference_wrapper<const T>> perm;
	perm.reserve(v.size());
	for (auto i : indices)
		perm.emplace_back(std::cref(v[i]));

	return perm;
}

//TODO Select parents based on fitness scores
std::pair<std::unique_ptr<GeneticModel>, std::unique_ptr<GeneticModel>> BasicGeneticAlgorithm::selectParents()
{
	std::pair<std::unique_ptr<GeneticModel>, std::unique_ptr<GeneticModel>> parents;

	parents.first = models[0]->clone();
	parents.second = models[0]->clone();

	double selection = (double) rand() / RAND_MAX;
	double fitnessSum = std::accumulate(fitnesses.begin(), fitnesses.end(), 0.0);

	int i = 0;
	while (selection > 0)
	{
		selection -= fitnesses[i] / fitnessSum;
		i++;
	}
	parents.first = models[i]->clone();

	selection = (double) rand() / RAND_MAX;
	i = 0;
	while (selection > 0)
	{
		selection -= fitnesses[i] / fitnessSum;
		i++;
	}
	parents.second = models[i]->clone();

	return parents;
}

void BasicGeneticAlgorithm::runGeneration()
{
	calculateFitnesses();

	std::vector<std::unique_ptr<GeneticModel>> newGeneration;

	for (int i = 0; i < GENERATION_SIZE; i++)
	{
		std::unique_ptr<GeneticModel> child = models[0]->clone();

		std::pair<std::unique_ptr<GeneticModel>, std::unique_ptr<GeneticModel>> parents = selectParents();
		std::vector<double> newParams = combineParameters(parents.first->getParameters(), parents.second->getParameters());
		child->setParameters(newParams);

		newGeneration.push_back(std::move(child));
	}

	models = std::move(newGeneration);
}

void BasicGeneticAlgorithm::train(std::unique_ptr<GeneticModel> modelTemplate, std::vector<trainingItem> tData, int generations)
{
	trainingData = std::move(tData);

	models.clear();
	for (int i = 0; i < GENERATION_SIZE; i++)
	{
		//TODO give each clone random parameters
		models.push_back(modelTemplate->clone());
	}

	continueTraining(generations);
}

void BasicGeneticAlgorithm::continueTraining(int generations)
{
	for (int i = 0; i < generations; i++) runGeneration();
}

std::unique_ptr<GeneticModel> BasicGeneticAlgorithm::getBestModel()
{
	return std::make_unique<LinearGeneticModel>(0);
}
